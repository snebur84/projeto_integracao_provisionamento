---
name: Deploy GCP infra

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy (e.g., prod, staging)'
        required: true
        default: prod

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Check required GCP secrets
        run: |
          set -euo pipefail
          if [ -z "${{ secrets.GCP_SA_KEY }}" ]; then
            echo "ERROR: missing secret GCP_SA_KEY"
            exit 1
          fi
          if [ -z "${{ secrets.GCP_PROJECT }}" ]; then
            echo "ERROR: missing secret GCP_PROJECT"
            exit 1
          fi

  deploy-gcp:
    runs-on: ubuntu-latest
    needs: validate
    env:
      TF_IN_AUTOMATION: true

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: List bootstrap dir (debug)
        run: |
          echo "Listing infra/terraform/bootstrap/gcp"
          ls -la infra/terraform/bootstrap/gcp || true

      - name: Authenticate to GCP (github action)
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Setup gcloud CLI
        uses: google-github-actions/setup-gcloud@v1
        with:
          service_account_key: ${{ secrets.GCP_SA_KEY }}
          project_id: ${{ secrets.GCP_PROJECT }}

      - name: Validate Service Account and Storage permissions
        env:
          GCP_PROJECT: ${{ secrets.GCP_PROJECT }}
          GCP_SA_KEY: ${{ secrets.GCP_SA_KEY }}
        run: |
          set -euo pipefail

          # Write key to temporary file with strict perms and validate it
          printf '%s' "$GCP_SA_KEY" > /tmp/gcp_key.json
          chmod 600 /tmp/gcp_key.json

          CLIENT_EMAIL=$(jq -r '.client_email // empty' /tmp/gcp_key.json || true)
          if [ -z "$CLIENT_EMAIL" ]; then
            echo "ERROR: service account key missing client_email or is invalid"
            rm -f /tmp/gcp_key.json
            exit 1
          fi
          echo "Service account: $CLIENT_EMAIL"

          # double-check auth using gcloud
          gcloud auth activate-service-account --key-file=/tmp/gcp_key.json --project="$GCP_PROJECT"
          echo "Active account:"
          gcloud auth list
          echo "Project config:"
          gcloud config get-value project || true

          # Ensure Cloud Storage API is available (try enabling if absent)
          if gcloud services list --enabled --project="$GCP_PROJECT" \
             --filter="NAME:storage.googleapis.com" --format="value(NAME)" \
             | grep -q storage.googleapis.com; then
            echo "Cloud Storage API enabled"
          else
            echo "Cloud Storage API not enabled; attempting to enable (may fail with insufficient perms)"
            gcloud services enable storage.googleapis.com --project="$GCP_PROJECT" || true
          fi

          # Quick permission check for listing buckets
          if gsutil ls -p "$GCP_PROJECT" >/dev/null 2>&1; then
            echo "gsutil access OK"
          else
            echo "Warning: gsutil could not list buckets. The SA may lack storage permissions."
            echo "IAM roles for the SA (may fail if not permitted):"
            gcloud projects get-iam-policy "$GCP_PROJECT" --format=json \
              | jq -r --arg sa "serviceAccount:$CLIENT_EMAIL" \
                '.bindings[] | select(.members[]? == $sa) | .role' || true
          fi

          rm -f /tmp/gcp_key.json

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.7

      - name: Bootstrap - write terraform.tfvars
        working-directory: infra/terraform/bootstrap/gcp
        env:
          ENV_NAME: ${{ github.event.inputs.environment }}
          GCP_REGION: ${{ secrets.GCP_REGION }}
          GCP_PROJECT: ${{ secrets.GCP_PROJECT }}
        run: |
          set -euo pipefail

          env="${ENV_NAME:-prod}"
          project="${GCP_PROJECT}"
          region="${GCP_REGION:-us-central1}"

          # Build a valid GCS bucket name (lowercase, replace invalid chars, limit length)
          bucket="${project}-tfstate-${env}"
          bucket=$(printf '%s' "$bucket" \
            | tr '[:upper:]' '[:lower:]' \
            | sed 's/[^a-z0-9-]/-/g' \
            | cut -c1-63)

          printf 'project = "%s"\n' "$project" > terraform.tfvars
          printf 'region = "%s"\n' "$region" >> terraform.tfvars
          printf 'state_bucket_name = "%s"\n' "$bucket" >> terraform.tfvars

          echo "Wrote terraform.tfvars (safe preview):"
          sed -n '1,120p' terraform.tfvars || true

      - name: Import existing state bucket if present
        working-directory: infra/terraform/bootstrap/gcp
        env:
          TF_INPUT: "false"
          TF_VAR_project: ${{ secrets.GCP_PROJECT }}
          TF_VAR_region: ${{ secrets.GCP_REGION }}
        run: |
          set -euo pipefail

          if [ ! -f terraform.tfvars ]; then
            echo "terraform.tfvars not found; skipping import check"
            exit 0
          fi

          echo "terraform.tfvars contents (for debug):"
          sed -n '1,120p' terraform.tfvars || true

          BUCKET=$(awk -F'"' '/state_bucket_name/ {print $2; exit}' terraform.tfvars || true)
          if [ -z "$BUCKET" ]; then
            echo "state_bucket_name not found in terraform.tfvars; skipping import"
            exit 0
          fi

          echo "Checking if bucket gs://$BUCKET exists..."
          if gsutil ls -b "gs://$BUCKET" >/dev/null 2>&1; then
            echo "Bucket exists — ensuring Terraform state knows about it."

            # init required before import
            terraform init -input=false

            # if resource already in state, skip import
            if terraform state list | grep -q '^google_storage_bucket\.terraform_state$'; then
              echo "google_storage_bucket.terraform_state already in state; skipping import."
            else
              # pass -var-file and explicit -var to avoid interactive prompts
              terraform import -lock=false -var-file=terraform.tfvars \
                -var="project=${TF_VAR_project}" -var="region=${TF_VAR_region}" \
                'google_storage_bucket.terraform_state' "$BUCKET" || {
                echo "terraform import failed"
                terraform state list || true
                exit 1
              }
            fi
          else
            echo "Bucket does not exist — Terraform will create it."
          fi

      - name: Bootstrap - init and apply
        working-directory: infra/terraform/bootstrap/gcp
        run: |
          set -euo pipefail
          terraform init -input=false
          terraform apply -auto-approve -input=false

      - name: Get bootstrap outputs and export TF_BUCKET (robust)
        working-directory: infra/terraform/bootstrap/gcp
        run: |
          set -euo pipefail

          TF_BUCKET=""

          # 1) Prefer -raw (returns only the value when available)
          if terraform output -help 2>/dev/null | grep -q '\-raw'; then
            TF_BUCKET=$(terraform output -raw state_bucket 2>/dev/null || true)
            if [ -z "$TF_BUCKET" ]; then
              TF_BUCKET=$(terraform output -raw state_bucket_name 2>/dev/null || true)
            fi
          fi

          # 2) Fallback: capture -json output, strip any leading log lines, then parse
          if [ -z "$TF_BUCKET" ]; then
            # capture output (stdout may contain JSON, stderr captured separately)
            OUT=$(terraform output -json -no-color 2>/tmp/terraform_output.err || true)

            # remove any lines before the first "{" (defensive against wrappers/extra prints)
            # awk prints from the first line that contains a "{" until EOF
            printf '%s\n' "$OUT" | awk 'BEGIN{p=0} /{/ {p=1} p{print}' > /tmp/terraform_output.json || true

            if jq -e . /tmp/terraform_output.json >/dev/null 2>&1; then
              echo "Available outputs (bootstrap):"
              jq -r 'keys[]' /tmp/terraform_output.json || true
              TF_BUCKET=$(jq -r '(.state_bucket.value // .state_bucket_name.value // .state_bucket // .state_bucket_name // empty)' /tmp/terraform_output.json || true)
            else
              echo "ERROR: terraform output -json produced invalid JSON. Stderr (for debug):"
              sed -n '1,200p' /tmp/terraform_output.err || true
            fi

            rm -f /tmp/terraform_output.json /tmp/terraform_output.err || true
          fi

          if [ -z "$TF_BUCKET" ]; then
            echo "ERROR: could not determine TF_BUCKET from bootstrap outputs."
            echo "Make sure the bootstrap module defines output 'state_bucket' or 'state_bucket_name'."
            exit 6
          fi

          echo "TF_BUCKET=$TF_BUCKET" >> $GITHUB_ENV
          echo "Exported TF_BUCKET=$TF_BUCKET"

      - name: Write backend.hcl for GCP infra
        env:
          TF_BUCKET: ${{ env.TF_BUCKET }}
          ENV_NAME: ${{ github.event.inputs.environment }}
        run: |
          set -euo pipefail
          mkdir -p infra/terraform/gcp
          env="${ENV_NAME:-prod}"
          printf 'bucket = "%s"\n' "$TF_BUCKET" > infra/terraform/gcp/backend.hcl
          printf 'prefix = "%s"\n' "env/${env}" >> infra/terraform/gcp/backend.hcl
          sed -n '1,120p' infra/terraform/gcp/backend.hcl

      - name: Terraform init (gcp infra)
        working-directory: infra/terraform/gcp
        run: |
          set -euo pipefail
          terraform init -backend-config=backend.hcl -reconfigure -input=false

      - name: Terraform apply (gcp infra)
        working-directory: infra/terraform/gcp
        run: |
          set -euo pipefail
          terraform apply -auto-approve -input=false

      - name: Output results
        if: success()
        working-directory: infra/terraform/gcp
        run: terraform output -json
