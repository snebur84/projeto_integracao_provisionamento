---
name: Deploy to Render with Terraform (Render Postgres + external Mongo)

# Manual trigger only
on:
  workflow_dispatch:

concurrency:
  group: deploy-render
  cancel-in-progress: true

permissions:
  contents: read
  id-token: write

jobs:
  terraform:
    runs-on: ubuntu-latest
    env:
      # Provider Render também aceita a API key via variável de ambiente RENDER_API_KEY.
      RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: '1.5.7'

      - name: Ensure jq is installed
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update && sudo apt-get install -y jq
          fi

      - name: Check if Render service exists (set TF_VAR_create_service accordingly)
        working-directory: infra/terraform/render
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          RENDER_SERVICE_NAME: ${{ secrets.RENDER_SERVICE_NAME }}
        run: |
          set -euo pipefail
          if [ -z "${RENDER_SERVICE_NAME:-}" ]; then
            echo "ERROR: secret RENDER_SERVICE_NAME is not set. Please set it in repository secrets."
            exit 1
          fi

          echo "Looking up Render service by name: ${RENDER_SERVICE_NAME}"
          SERVICE_ID=$(curl -s -H "Authorization: Bearer ${RENDER_API_KEY}" \
            "https://api.render.com/v1/services" \
            | jq -r --arg name "${RENDER_SERVICE_NAME}" '.[] | select(.name==$name) | .id' | head -n1 || true)

          if [ -n "$SERVICE_ID" ]; then
            echo "Found existing Render service: $SERVICE_ID"
            echo "TF_VAR_create_service=false" >> $GITHUB_ENV
            echo "RENDER_EXISTING_SERVICE_ID=$SERVICE_ID" >> $GITHUB_ENV
          else
            echo "No existing service found with name '${RENDER_SERVICE_NAME}'. Terraform will create resources."
            echo "TF_VAR_create_service=true" >> $GITHUB_ENV
          fi

      - name: Check if Render Postgres DB exists (set TF_VAR_create_postgres accordingly and capture connection)
        working-directory: infra/terraform/render
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          RENDER_POSTGRES_NAME: ${{ secrets.RENDER_POSTGRES_NAME }}
        run: |
          set -euo pipefail

          # If no expected db name provided, assume terraform should create it
          if [ -z "${RENDER_POSTGRES_NAME:-}" ]; then
            echo "RENDER_POSTGRES_NAME not set; Terraform will manage Postgres creation by default."
            echo "TF_VAR_create_postgres=true" >> $GITHUB_ENV
            exit 0
          fi

          echo "Looking up Render Postgres database by name: ${RENDER_POSTGRES_NAME}"
          # Try to find DB in Render databases list
          DB_JSON=$(curl -s -H "Authorization: Bearer ${RENDER_API_KEY}" "https://api.render.com/v1/databases" || true)
          DB_ID=$(echo "$DB_JSON" | jq -r --arg name "${RENDER_POSTGRES_NAME}" '.[] | select(.name==$name) | .id' | head -n1 || true)

          if [ -n "$DB_ID" ]; then
            echo "Found existing Render Postgres DB: ${DB_ID}"
            echo "TF_VAR_create_postgres=false" >> $GITHUB_ENV
            echo "RENDER_EXISTING_POSTGRES_ID=${DB_ID}" >> $GITHUB_ENV

            # Try to extract a connection string from common fields returned by Render
            # Try several possibilities to be tolerant with provider/module variations
            POSTGRES_CONN=$(echo "$DB_JSON" | jq -r --arg id "$DB_ID" '.[] | select(.id==$id) | (.connectionString // .connection_info.connectionString // .connection_uri // .connection_url // .connectionStringUri // .connectionStringRaw // "")' | head -n1 || true)

            if [ -n "$POSTGRES_CONN" ] && [ "$POSTGRES_CONN" != "null" ]; then
              echo "Captured connection string from Render API for existing DB."
              # export to env for later use
              echo "RENDER_EXISTING_POSTGRES_CONN=${POSTGRES_CONN}" >> $GITHUB_ENV
            else
              echo "Could not find a connection string field for existing DB via API response. Terraform output or manual config will be used."
            fi
          else
            echo "No existing Render Postgres DB found with name '${RENDER_POSTGRES_NAME}'. Terraform will create the DB if configured."
            echo "TF_VAR_create_postgres=true" >> $GITHUB_ENV
          fi

      - name: Terraform Init
        working-directory: infra/terraform/render
        run: terraform init -input=false

      - name: Terraform Validate
        working-directory: infra/terraform/render
        run: terraform validate || true

      - name: Terraform Plan (passando secrets como TF_VAR_*)
        working-directory: infra/terraform/render
        env:
          TF_VAR_render_api_key: ${{ secrets.RENDER_API_KEY }}
          TF_VAR_render_owner_id: ${{ secrets.RENDER_OWNER_ID }}
          TF_VAR_django_secret_key: ${{ secrets.DJANGO_SECRET_KEY }}
          TF_VAR_django_debug: ${{ secrets.DJANGO_DEBUG }}
          TF_VAR_django_allowed_hosts: ${{ secrets.DJANGO_ALLOWED_HOSTS }}
          TF_VAR_django_superuser_username: ${{ secrets.DJANGO_SUPERUSER_USERNAME }}
          TF_VAR_django_superuser_email: ${{ secrets.DJANGO_SUPERUSER_EMAIL }}
          TF_VAR_django_superuser_password: ${{ secrets.DJANGO_SUPERUSER_PASSWORD }}
          # Legacy MySQL variables retained for compatibility
          TF_VAR_mysql_database: ${{ secrets.MYSQL_DATABASE }}
          TF_VAR_mysql_user: ${{ secrets.MYSQL_USER }}
          TF_VAR_mysql_password: ${{ secrets.MYSQL_PASSWORD }}
          TF_VAR_mysql_root_password: ${{ secrets.MYSQL_ROOT_PASSWORD }}
          TF_VAR_mysql_port: ${{ secrets.MYSQL_PORT }}
          # New Postgres variables
          TF_VAR_postgres_database: ${{ secrets.POSTGRES_DATABASE }}
          TF_VAR_postgres_user: ${{ secrets.POSTGRES_USER }}
          TF_VAR_postgres_password: ${{ secrets.POSTGRES_PASSWORD }}
          TF_VAR_postgres_port: ${{ secrets.POSTGRES_PORT }}
          TF_VAR_postgres_name: ${{ secrets.RENDER_POSTGRES_NAME }}
          # MongoDB (external)
          TF_VAR_mongodb_url: ${{ secrets.MONGODB_URL }}
          TF_VAR_mongodb_root_username: ${{ secrets.MONGODB_ROOT_USERNAME }}
          TF_VAR_mongodb_root_password: ${{ secrets.MONGODB_ROOT_PASSWORD }}
          TF_VAR_mongodb_database: ${{ secrets.MONGODB_DATABASE }}
          TF_VAR_provision_api_key: ${{ secrets.PROVISION_API_KEY }}
          # Flags set by earlier steps (create or reuse)
          TF_VAR_create_service: ${{ env.TF_VAR_create_service }}
          TF_VAR_create_postgres: ${{ env.TF_VAR_create_postgres }}
        run: terraform plan -input=false -out=tfplan || terraform plan -input=false -out=tfplan || true

      - name: Terraform Apply
        working-directory: infra/terraform/render
        env:
          TF_VAR_render_api_key: ${{ secrets.RENDER_API_KEY }}
          TF_VAR_render_owner_id: ${{ secrets.RENDER_OWNER_ID }}
          TF_VAR_django_secret_key: ${{ secrets.DJANGO_SECRET_KEY }}
          TF_VAR_django_debug: ${{ secrets.DJANGO_DEBUG }}
          TF_VAR_django_allowed_hosts: ${{ secrets.DJANGO_ALLOWED_HOSTS }}
          TF_VAR_django_superuser_username: ${{ secrets.DJANGO_SUPERUSER_USERNAME }}
          TF_VAR_django_superuser_email: ${{ secrets.DJANGO_SUPERUSER_EMAIL }}
          TF_VAR_django_superuser_password: ${{ secrets.DJANGO_SUPERUSER_PASSWORD }}
          TF_VAR_mysql_database: ${{ secrets.MYSQL_DATABASE }}
          TF_VAR_mysql_user: ${{ secrets.MYSQL_USER }}
          TF_VAR_mysql_password: ${{ secrets.MYSQL_PASSWORD }}
          TF_VAR_mysql_root_password: ${{ secrets.MYSQL_ROOT_PASSWORD }}
          TF_VAR_mysql_port: ${{ secrets.MYSQL_PORT }}
          TF_VAR_postgres_database: ${{ secrets.POSTGRES_DATABASE }}
          TF_VAR_postgres_user: ${{ secrets.POSTGRES_USER }}
          TF_VAR_postgres_password: ${{ secrets.POSTGRES_PASSWORD }}
          TF_VAR_postgres_port: ${{ secrets.POSTGRES_PORT }}
          TF_VAR_postgres_name: ${{ secrets.RENDER_POSTGRES_NAME }}
          TF_VAR_mongodb_url: ${{ secrets.MONGODB_URL }}
          TF_VAR_mongodb_root_username: ${{ secrets.MONGODB_ROOT_USERNAME }}
          TF_VAR_mongodb_root_password: ${{ secrets.MONGODB_ROOT_PASSWORD }}
          TF_VAR_mongodb_database: ${{ secrets.MONGODB_DATABASE }}
          TF_VAR_provision_api_key: ${{ secrets.PROVISION_API_KEY }}
          TF_VAR_create_service: ${{ env.TF_VAR_create_service }}
          TF_VAR_create_postgres: ${{ env.TF_VAR_create_postgres }}
        run: |
          set -euo pipefail
          if [ -f tfplan ]; then
            terraform apply -input=false -auto-approve tfplan
          else
            terraform apply -input=false -auto-approve || true
          fi

      - name: Terraform Output (JSON)
        if: ${{ success() }}
        working-directory: infra/terraform/render
        env:
          TF_VAR_render_api_key: ${{ secrets.RENDER_API_KEY }}
        run: terraform output -json > tf-output.json || true

      - name: Show outputs for debugging
        if: always()
        working-directory: infra/terraform/render
        run: |
          echo "---- Terraform outputs (tf-output.json) ----"
          cat tf-output.json || true
          echo "---- End outputs ----"

      - name: Configure Render env vars (DATABASE_URL, MONGODB_URL, DJANGO_SETTINGS_MODULE, secrets)
        if: ${{ success() }}
        working-directory: infra/terraform/render
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          MONGODB_URL: ${{ secrets.MONGODB_URL }}
          DJANGO_SECRET_KEY: ${{ secrets.DJANGO_SECRET_KEY }}
          DJANGO_DEBUG: ${{ secrets.DJANGO_DEBUG }}
          DJANGO_ALLOWED_HOSTS: ${{ secrets.DJANGO_ALLOWED_HOSTS }}
          # These may have been set earlier if DB/service already existed
          RENDER_EXISTING_SERVICE_ID: ${{ env.RENDER_EXISTING_SERVICE_ID }}
          RENDER_EXISTING_POSTGRES_CONN: ${{ env.RENDER_EXISTING_POSTGRES_CONN }}
          RENDER_EXISTING_POSTGRES_ID: ${{ env.RENDER_EXISTING_POSTGRES_ID }}
          RENDER_SERVICE_NAME: ${{ secrets.RENDER_SERVICE_NAME }}
        run: |
          set -euo pipefail

          # Determine service id to configure
          if [ -n "${RENDER_EXISTING_SERVICE_ID:-}" ]; then
            SERVICE_ID="${RENDER_EXISTING_SERVICE_ID}"
            echo "Using existing Render service id from earlier step: ${SERVICE_ID}"
          else
            SERVICE_ID=$(jq -r '.provision_service_id.value // .service_id.value // .service.value // ""' tf-output.json 2>/dev/null || echo "")
            if [ -z "$SERVICE_ID" ]; then
              echo "Service id not found in terraform outputs; attempting lookup by name..."
              SERVICE_ID=$(curl -s -H "Authorization: Bearer ${RENDER_API_KEY}" "https://api.render.com/v1/services" \
                | jq -r --arg name "${RENDER_SERVICE_NAME}" '.[] | select(.name==$name) | .id' | head -n1 || true)
            fi
          fi

          if [ -z "$SERVICE_ID" ]; then
            echo "ERROR: Could not determine Render service id. Aborting env var configuration."
            exit 1
          fi

          echo "Render service id to configure: ${SERVICE_ID}"

          # Determine Postgres connection string
          # Priority:
          # 1) Terraform output (common keys)
          # 2) Previously discovered existing DB connection from API (RENDER_EXISTING_POSTGRES_CONN)
          # 3) Query Render API for DB connected to the service or DB with given name
          POSTGRES_URL=$(jq -r '.postgres_database_url.value // .postgres_url.value // .database_url.value // .database.connection_string.value // ""' tf-output.json 2>/dev/null || echo "")

          if [ -z "$POSTGRES_URL" ] && [ -n "${RENDER_EXISTING_POSTGRES_CONN:-}" ]; then
            POSTGRES_URL="${RENDER_EXISTING_POSTGRES_CONN}"
            echo "Using existing Postgres connection captured earlier."
          fi

          if [ -z "$POSTGRES_URL" ]; then
            # Try to find DB attached to the service via Render API
            echo "Attempting to discover DB via Render API..."
            # Get all databases and select one that references the service id or matches the configured DB name
            DB_CANDIDATE=$(curl -s -H "Authorization: Bearer ${RENDER_API_KEY}" "https://api.render.com/v1/databases" || true)
            # Try service attachment match
            POSTGRES_URL=$(echo "$DB_CANDIDATE" | jq -r --arg sid "$SERVICE_ID" '.[] | select(.serviceId==$sid) | (.connectionString // .connection_info.connectionString // .connection_uri // .connection_url // "")' | head -n1 || true)
            if [ -z "$POSTGRES_URL" ]; then
              # Try by db name if secret provided
              if [ -n "${RENDER_POSTGRES_NAME:-}" ]; then
                POSTGRES_URL=$(echo "$DB_CANDIDATE" | jq -r --arg name "${RENDER_POSTGRES_NAME}" '.[] | select(.name==$name) | (.connectionString // .connection_info.connectionString // .connection_uri // .connection_url // "")' | head -n1 || true)
              fi
            fi
          fi

          if [ -z "$POSTGRES_URL" ]; then
            echo "Warning: Postgres connection string not found via Terraform outputs nor via Render API discovery. DATABASE_URL will not be set automatically."
          else
            echo "Postgres connection string resolved; setting DATABASE_URL on service."
          fi

          # Helper to upsert env var in Render service:
          set_env_var() {
            KEY="$1"
            VALUE="$2"
            PAYLOAD=$(jq -n --arg key "$KEY" --arg value "$VALUE" '{"key":$key,"value":$value,"scope":"RUN_TIME"}')
            HTTP=$(curl -s -o /tmp/_render_env_resp -w "%{http_code}" -X POST "https://api.render.com/v1/services/${SERVICE_ID}/env-vars" \
              -H "Authorization: Bearer ${RENDER_API_KEY}" \
              -H "Content-Type: application/json" \
              -d "$PAYLOAD" || true)
            if [ "${HTTP}" -ge 400 ]; then
              EXISTING_ID=$(curl -s -H "Authorization: Bearer ${RENDER_API_KEY}" "https://api.render.com/v1/services/${SERVICE_ID}/env-vars" \
                | jq -r --arg k "$KEY" '.[] | select(.key==$k) | .id' | head -n1 || true)
              if [ -n "$EXISTING_ID" ]; then
                echo "Updating existing env var ${KEY} (id ${EXISTING_ID})"
                curl -s -X PATCH "https://api.render.com/v1/services/${SERVICE_ID}/env-vars/${EXISTING_ID}" \
                  -H "Authorization: Bearer ${RENDER_API_KEY}" \
                  -H "Content-Type: application/json" \
                  -d "$PAYLOAD" || true
              else
                echo "Failed to create env var ${KEY} (HTTP ${HTTP}), and no existing var found to update."
              fi
            else
              echo "Env var ${KEY} created/ensured (HTTP ${HTTP})."
            fi
          }

          # Set DATABASE_URL if available
          if [ -n "$POSTGRES_URL" ]; then
            set_env_var "DATABASE_URL" "$POSTGRES_URL"
          fi

          # Set MONGODB_URL from repository secret
          if [ -n "${MONGODB_URL:-}" ]; then
            set_env_var "MONGODB_URL" "${MONGODB_URL}"
          else
            echo "Warning: secret MONGODB_URL not set; Mongo will not be configured in Render env."
          fi

          # Ensure Django uses the render-specific settings module
          set_env_var "DJANGO_SETTINGS_MODULE" "provision.settings_render"

          # Propagate Django secrets/flags
          if [ -n "${DJANGO_SECRET_KEY:-}" ]; then
            set_env_var "DJANGO_SECRET_KEY" "${DJANGO_SECRET_KEY}"
          fi
          if [ -n "${DJANGO_DEBUG:-}" ]; then
            set_env_var "DJANGO_DEBUG" "${DJANGO_DEBUG}"
          fi
          if [ -n "${DJANGO_ALLOWED_HOSTS:-}" ]; then
            set_env_var "DJANGO_ALLOWED_HOSTS" "${DJANGO_ALLOWED_HOSTS}"
          fi

          echo "Render environment variables configuration completed."

      - name: Done
        run: echo "Deploy/Configuração completada (verifique outputs e logs do Render)."
