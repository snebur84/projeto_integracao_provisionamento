---
# Deploy workflow: detect or create infra and deploy app via SSM.
# Trigger: manual (workflow_dispatch) with `environment` input.
on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: false
        default: 'prod'
      aws_region:
        description: 'AWS region (overrides secret)'
        required: false
        default: 'us-east-1'

jobs:
  check_infra:
    name: Check for existing EC2
    runs-on: ubuntu-latest
    outputs:
      found: ${{ steps.check.outputs.found }}
      instance_id: ${{ steps.check.outputs.instance_id }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN || '' }}
          aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}

      - name: Test identity
        run: aws sts get-caller-identity

      - name: Check for instance by tag
        id: check
        run: |
          set -euo pipefail
          ENV="${{ github.event.inputs.environment }}"
          TAG_KEY="Project"
          INSTANCES=$(aws ec2 describe-instances \
            --filters "Name=tag:${TAG_KEY},Values=${ENV}" \
            "Name=instance-state-name,Values=pending,running,stopping,stopped" \
            --query 'Reservations[].Instances[].InstanceId' \
            --output text || true)

          if [ -z "$INSTANCES" ]; then
            echo "found=false" >> "$GITHUB_OUTPUT"
            echo "instance_id=" >> "$GITHUB_OUTPUT"
          else
            FIRST=$(echo "$INSTANCES" | awk '{print $1}')
            echo "found=true" >> "$GITHUB_OUTPUT"
            echo "instance_id=$FIRST" >> "$GITHUB_OUTPUT"
          fi

  terraform:
    name: Terraform (create infra)
    runs-on: ubuntu-latest
    needs: check_infra
    if: needs.check_infra.outputs.found == 'false'
    outputs:
      instance_id: ${{ steps.set_outputs.outputs.instance_id }}
      staging_bucket: ${{ steps.set_outputs.outputs.staging_bucket }}
    env:
      TF_IN_AUTOMATION: true
      TF_VAR_public_key: ${{ secrets.TF_VAR_public_key || '' }}
      TF_VAR_tfstate_bucket: ${{ secrets.TF_VAR_tfstate_bucket || '' }}
      TF_VAR_tfstate_lock_table: ${{ secrets.TF_VAR_tfstate_lock_table || '' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: "1.5.0"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Terraform init
        working-directory: infra/terraform
        run: terraform init -input=false

      - name: Terraform validate
        working-directory: infra/terraform
        run: terraform validate

      - name: Terraform plan
        working-directory: infra/terraform
        run: terraform plan -input=false -out=tfplan

      - name: Terraform apply
        working-directory: infra/terraform
        run: terraform apply -input=false -auto-approve tfplan

      - name: Export outputs
        id: set_outputs
        working-directory: infra/terraform
        run: |
          set -euo pipefail
          terraform output -json > /tmp/tf_outputs.json
          INSTANCE_ID=$(jq -r '.instance_id.value' /tmp/tf_outputs.json)
          STAGING_BUCKET=$(jq -r '.staging_bucket.value' /tmp/tf_outputs.json)
          echo "instance_id=$INSTANCE_ID" >> "$GITHUB_OUTPUT"
          echo "staging_bucket=$STAGING_BUCKET" >> "$GITHUB_OUTPUT"

  deploy:
    name: Upload and deploy to EC2 via SSM
    runs-on: ubuntu-latest
    needs: [check_infra, terraform]
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      ENVIRONMENT: ${{ github.event.inputs.environment }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Determine instance and bucket
        id: prep
        run: |
          set -euo pipefail
          CHECK_FOUND="${{ needs.check_infra.outputs.found }}"
          CHECK_INSTANCE="${{ needs.check_infra.outputs.instance_id }}"
          TF_INSTANCE="${{ needs.terraform.outputs.instance_id }}"
          TF_STAGING="${{ needs.terraform.outputs.staging_bucket }}"
          S3_OVERRIDE="${{ secrets.S3_BUCKET || '' }}"

          if [ "$CHECK_FOUND" = "true" ] && [ -n "$CHECK_INSTANCE" ]; then
            INSTANCE_ID="$CHECK_INSTANCE"
          elif [ -n "$TF_INSTANCE" ]; then
            INSTANCE_ID="$TF_INSTANCE"
          else
            echo "No instance id available"
            exit 1
          fi

          if [ -n "$TF_STAGING" ] && [ "$TF_STAGING" != "null" ]; then
            STAGING_BUCKET="$TF_STAGING"
          elif [ -n "$S3_OVERRIDE" ]; then
            STAGING_BUCKET="$S3_OVERRIDE"
          else
            echo "No staging bucket available"
            exit 1
          fi

          echo "instance_id=$INSTANCE_ID" >> "$GITHUB_OUTPUT"
          echo "staging_bucket=$STAGING_BUCKET" >> "$GITHUB_OUTPUT"

      - name: Upload provision script
        run: |
          set -euo pipefail
          STAGING_BUCKET="${{ steps.prep.outputs.staging_bucket }}"
          aws s3 cp scripts/provision_ubuntu_ec2.sh \
            s3://"$STAGING_BUCKET"/provision_ubuntu_ec2.sh \
            --acl private

      - name: Ensure SSM secrets
        id: ensure_ssm
        env:
          ENV_PATH: "/provision/${{ github.event.inputs.environment }}"
        run: |
          set -euo pipefail
          check_and_put() {
            name="$1"; val="$2"
            if aws ssm get-parameter --name "$name" \
               --with-decryption >/dev/null 2>&1; then
              return 0
            fi
            aws ssm put-parameter --name "$name" --value "$val" \
              --type "SecureString" --overwrite
          }

          SECRET_KEY=$(python -c "import secrets; print(secrets.token_urlsafe(50))")
          DB_PASS=$(openssl rand -base64 18)

          if [ -n "${{ secrets.PROVISION_API_KEY }}" ]; then
            PROVISION_KEY="${{ secrets.PROVISION_API_KEY }}"
          else
            PROVISION_KEY=$(uuidgen)
          fi

          SK="${ENV_PATH}/SECRET_KEY"
          DBP="${ENV_PATH}/DB_PASSWORD"
          PK="${ENV_PATH}/PROVISION_API_KEY"
          SUP_USER="${ENV_PATH}/DJANGO_SUPERUSER_USERNAME"
          SUP_EMAIL="${ENV_PATH}/DJANGO_SUPERUSER_EMAIL"
          SUP_PASS="${ENV_PATH}/DJANGO_SUPERUSER_PASSWORD"

          check_and_put "$SK" "$SECRET_KEY"
          check_and_put "$DBP" "$DB_PASS"
          check_and_put "$PK" "$PROVISION_KEY"

          if [ -n "${{ secrets.DJANGO_SUPERUSER_USERNAME }}" ]; then
            aws ssm put-parameter --name "$SUP_USER" \
              --value "${{ secrets.DJANGO_SUPERUSER_USERNAME }}" \
              --type "SecureString" --overwrite
          fi

          if [ -n "${{ secrets.DJANGO_SUPERUSER_EMAIL }}" ]; then
            aws ssm put-parameter --name "$SUP_EMAIL" \
              --value "${{ secrets.DJANGO_SUPERUSER_EMAIL }}" \
              --type "SecureString" --overwrite
          fi

          if [ -n "${{ secrets.DJANGO_SUPERUSER_PASSWORD }}" ]; then
            aws ssm put-parameter --name "$SUP_PASS" \
              --value "${{ secrets.DJANGO_SUPERUSER_PASSWORD }}" \
              --type "SecureString" --overwrite
          fi

          echo "ssm_prefix=$ENV_PATH" >> "$GITHUB_OUTPUT"
          echo "secret_key_param=$SK" >> "$GITHUB_OUTPUT"
          echo "db_pass_param=$DBP" >> "$GITHUB_OUTPUT"
          echo "provision_key_param=$PK" >> "$GITHUB_OUTPUT"

      - name: Send SSM command to run provision script
        id: send_ssm
        env:
          INSTANCE_ID: ${{ steps.prep.outputs.instance_id }}
          STAGING_BUCKET: ${{ steps.prep.outputs.staging_bucket }}
        run: |
          set -euo pipefail
          INSTANCE_ID="${INSTANCE_ID}"
          STAGING_BUCKET="${STAGING_BUCKET}"

          PART1='aws s3 cp s3://'
          PART2="${STAGING_BUCKET}"
          PART3='/provision_ubuntu_ec2.sh /tmp/provision_ubuntu_ec2.sh'
          CMD_DOWNLOAD="$PART1$PART2$PART3"

          CMD_A=' && chmod +x /tmp/provision_ubuntu_ec2.sh'
          CMD_B=' && /bin/bash /tmp/provision_ubuntu_ec2.sh'
          CMD_FULL="$CMD_DOWNLOAD$CMD_A$CMD_B"

          CMD_JSON=$(printf '["%s"]' "$CMD_FULL")

          CMD_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "Deploy: download and run provision script" \
            --parameters commands="$CMD_JSON" \
            --timeout-seconds 900 \
            --query "Command.CommandId" --output text)

          echo "command_id=$CMD_ID" >> "$GITHUB_OUTPUT"

      - name: Wait for SSM result
        env:
          INSTANCE_ID: ${{ steps.prep.outputs.instance_id }}
        run: |
          set -euo pipefail
          CMD_ID=${{ steps.send_ssm.outputs.command_id }}
          INSTANCE_ID="${INSTANCE_ID}"

          ATTEMPTS=0
          while [ $ATTEMPTS -lt 120 ]; do
            sleep 5
            ((ATTEMPTS++))
            STATUS=$(aws ssm list-command-invocations \
              --command-id "$CMD_ID" --details --instance-id "$INSTANCE_ID" \
              --query "CommandInvocations[0].Status" \
              --output text 2>/dev/null || echo "Unknown")
            echo "SSM status: $STATUS"
            if [ "$STATUS" = "Success" ]; then
              exit 0
            fi
            if [[ "$STATUS" =~ ^(Failed|Cancelled|TimedOut|Undeliverable)$ ]]; then
              aws ssm list-command-invocations \
                --command-id "$CMD_ID" --details --instance-id "$INSTANCE_ID" || true
              exit 1
            fi
          done
          exit 1