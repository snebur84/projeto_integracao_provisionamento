---
# Workflow: Terraform -> create EC2 -> provision via user_data (presigned URL)
# Fixes applied:
# - ensure boolean inputs use real booleans (no quoted "true"/"false")
# - wrap long lines to <= 80 chars to satisfy yamllint line-length rule
on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment (e.g. prod)"
        required: true
        default: "prod"
      create_instance:
        description: "Create EC2 instance (true/false)"
        required: false
        default: true
      instance_type:
        description: "EC2 instance type"
        required: false
        default: "t3.micro"
      key_name:
        description: "EC2 key pair name (optional)"
        required: false
        default: ""
      subnet_id:
        description: "Subnet id (optional)"
        required: false
        default: ""
      security_group_ids:
        description: "Comma-separated SG ids (optional)"
        required: false
        default: ""
      script_path:
        description: "Path to provisioning script in repo"
        required: false
        default: "scripts/provision_ubuntu_full.sh"
      presign_ttl:
        description: "Presigned URL TTL in seconds"
        required: false
        default: "86400"

name: Terraform deploy + VM provision (user_data)

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Install Terraform
        run: |
          set -euo pipefail
          TERRAFORM_VERSION="${TERRAFORM_VERSION:-1.5.7}"
          ZIP="terraform_${TERRAFORM_VERSION}_linux_amd64.zip"
          curl -fsSLo "${ZIP}" \
            "https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/${ZIP}"
          unzip -q "${ZIP}"
          sudo mv terraform /usr/local/bin/terraform
          sudo chmod +x /usr/local/bin/terraform
          rm -f "${ZIP}"
          terraform version

      - name: Bootstrap backend (S3 + DynamoDB) if missing
        id: bootstrap
        working-directory: infra/terraform
        run: |
          set -euo pipefail
          REGION="${AWS_REGION:-us-east-1}"
          ENV="${{ github.event.inputs.environment }}"
          if [ -n "${{ secrets.TFSTATE_BUCKET }}" ]; then
            BUCKET="${{ secrets.TFSTATE_BUCKET }}"
          else
            BUCKET="provisionbucket-${ENV}"
          fi
          TABLE="${BUCKET}-locks"
          echo "bucket=${BUCKET}" >> "$GITHUB_OUTPUT"
          echo "dynamodb_table=${TABLE}" >> "$GITHUB_OUTPUT"
          echo "region=${REGION}" >> "$GITHUB_OUTPUT"

          if aws s3api head-bucket --bucket "${BUCKET}" 2>/dev/null; then
            echo "Bucket ${BUCKET} exists"
          else
            echo "Creating bucket ${BUCKET} in ${REGION}..."
            if [ "${REGION}" = "us-east-1" ]; then
              aws s3api create-bucket --bucket "${BUCKET}"
            else
              aws s3api create-bucket \
                --bucket "${BUCKET}" \
                --create-bucket-configuration \
                LocationConstraint="${REGION}"
            fi
            aws s3api put-bucket-versioning \
              --bucket "${BUCKET}" \
              --versioning-configuration Status=Enabled
            printf '%s\n' '{' \
              '  "Rules": [' \
              '    {' \
              '      "ApplyServerSideEncryptionByDefault": {' \
              '        "SSEAlgorithm": "AES256"' \
              '      }' \
              '    }' \
              '  ]' \
              '}' > enc.json
            aws s3api put-bucket-encryption \
              --bucket "${BUCKET}" \
              --server-side-encryption-configuration file://enc.json
          fi

          if aws dynamodb describe-table \
            --table-name "${TABLE}" --region "${REGION}" \
            >/dev/null 2>&1; then
            echo "DynamoDB table ${TABLE} exists"
          else
            aws dynamodb create-table \
              --table-name "${TABLE}" \
              --attribute-definitions \
              AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST --region "${REGION}"
            aws dynamodb wait table-exists \
              --table-name "${TABLE}" --region "${REGION}"
          fi

          printf 'bucket = "%s"\n' "${BUCKET}" > backend.hcl
          printf 'key    = "%s/terraform.tfstate"\n' "${ENV}" >> backend.hcl
          printf 'region = "%s"\n' "${REGION}" >> backend.hcl
          printf 'dynamodb_table = "%s"\n' "${TABLE}" >> backend.hcl
          printf 'encrypt = true\n' >> backend.hcl

      - name: Upload provision script and create presigned URL
        id: presign
        run: |
          set -euo pipefail
          STAGING_BUCKET="${{ steps.bootstrap.outputs.bucket }}"
          SCRIPT="${{ github.event.inputs.script_path }}"
          DEST="provision.sh"
          aws s3 cp "${SCRIPT}" \
            "s3://${STAGING_BUCKET}/${DEST}" --acl private
          TTL="${{ github.event.inputs.presign_ttl }}"
          PRESIGNED=$(aws s3 presign \
            "s3://${STAGING_BUCKET}/${DEST}" --expires-in "${TTL}")
          echo "presigned_url=${PRESIGNED}" >> "$GITHUB_OUTPUT"
          echo "Uploaded and presigned script"

      - name: Terraform validate & plan
        working-directory: infra/terraform
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
          TF_VAR_create_instance: ${{ github.event.inputs.create_instance }}
          TF_VAR_instance_type: ${{ github.event.inputs.instance_type }}
          TF_VAR_key_name: ${{ github.event.inputs.key_name }}
          TF_VAR_subnet_id: ${{ github.event.inputs.subnet_id }}
          TF_VAR_presigned_url: ${{ steps.presign.outputs.presigned_url }}
          TF_VAR_environment: ${{ github.event.inputs.environment }}
          SG_INPUT: ${{ github.event.inputs.security_group_ids }}
        run: |
          set -euo pipefail
          if [ -n "${SG_INPUT}" ]; then
            IFS=',' read -ra _SGARR <<<"${SG_INPUT}"
            SG_JSON="["
            first=true
            for sg in "${_SGARR[@]}"; do
              sgt=$(echo "$sg" | xargs)
              if [ -z "$sgt" ]; then
                continue
              fi
              if [ "$first" = true ]; then
                first=false
              else
                SG_JSON="${SG_JSON},"
              fi
              SG_JSON="${SG_JSON}\"${sgt}\""
            done
            SG_JSON="${SG_JSON}]"
          else
            SG_JSON='[]'
          fi
          export TF_VAR_sg_ids="${SG_JSON}"
          terraform init -backend-config=backend.hcl -reconfigure
          terraform validate
          terraform plan -out=tfplan -input=false

      - name: Terraform apply
        working-directory: infra/terraform
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
          TF_VAR_create_instance: ${{ github.event.inputs.create_instance }}
          TF_VAR_instance_type: ${{ github.event.inputs.instance_type }}
          TF_VAR_key_name: ${{ github.event.inputs.key_name }}
          TF_VAR_subnet_id: ${{ github.event.inputs.subnet_id }}
          TF_VAR_presigned_url: ${{ steps.presign.outputs.presigned_url }}
          TF_VAR_environment: ${{ github.event.inputs.environment }}
          SG_INPUT: ${{ github.event.inputs.security_group_ids }}
        run: |
          set -euo pipefail
          if [ -n "${SG_INPUT}" ]; then
            IFS=',' read -ra _SGARR <<<"${SG_INPUT}"
            SG_JSON="["
            first=true
            for sg in "${_SGARR[@]}"; do
              sgt=$(echo "$sg" | xargs)
              if [ -z "$sgt" ]; then
                continue
              fi
              if [ "$first" = true ]; then
                first=false
              else
                SG_JSON="${SG_JSON},"
              fi
              SG_JSON="${SG_JSON}\"${sgt}\""
            done
            SG_JSON="${SG_JSON}]"
          else
            SG_JSON='[]'
          fi
          export TF_VAR_sg_ids="${SG_JSON}"
          terraform apply -input=false -auto-approve tfplan

      - name: Print backend info
        run: |
          echo "bucket=${{ steps.bootstrap.outputs.bucket }}"
          echo "dynamodb_table=${{ steps.bootstrap.outputs.dynamodb_table }}"
          echo "region=${{ steps.bootstrap.outputs.region }}"
